import { BurnableNfts, NftCreateData, PricingPackagesTypes } from "@/types";
import {
  CreateNftBuilderContext,
  Metaplex,
  TransactionBuilder,
  sol,
  walletAdapterIdentity,
} from "@metaplex-foundation/js";
import { NftStorageDriverOptions, nftStorage } from "@metaplex-foundation/js-plugin-nft-storage";
import { mintV1 } from "@metaplex-foundation/mpl-bubblegum";
import { TokenStandard, burnV1, findMasterEditionPda, findMetadataPda, mplTokenMetadata } from "@metaplex-foundation/mpl-token-metadata";
import { Umi, none, publicKey } from "@metaplex-foundation/umi";
import { createUmi } from "@metaplex-foundation/umi-bundle-defaults";
import { walletAdapterIdentity as umiWalletAdapterIdentity } from "@metaplex-foundation/umi-signer-wallet-adapters";
import { fromWeb3JsPublicKey } from "@metaplex-foundation/umi-web3js-adapters";
import * as splToken from "@solana/spl-token";
import { AnchorWallet } from "@solana/wallet-adapter-react";
import { PublicKey, SystemProgram, Transaction, TransactionInstruction, TransactionMessage } from "@solana/web3.js";
import axios from "axios";
import { NFTStorage } from "nft.storage";
import {
  USDC,
  bonk,
  connection,
  dogWifHat,
  gecko,
  merkleTree,
  paymentWallet,
  paymentWalletUSDC,
  privateMerkleTree,
  sapphireCollectionMint,
  shdw,
} from "../constants";

export function getNftStorageClient() {
  return new NFTStorage({ token: process.env.NEXT_PUBLIC_NFT_STORAGE_KEY as string });
}

/**
 * Store an image to nft.storage by passing an image url
 * @param {string} imageUrl
 * @returns {Promise<string>}
 */
export async function uploadImageWithUrl(imageUrl: string) {
  const imgReq = await fetch(process.env.NEXT_PUBLIC_CORS_PROXY_URL! + imageUrl);
  const image = await imgReq.blob();

  const client = getNftStorageClient();
  const cid = await client.storeBlob(image);

  const storageUrl = `https://nftstorage.link/ipfs/${cid}`;
  return storageUrl;
}

/**
 * Store an image to nft.storage by passing a blob/file object
 * @param {Blob | File} imageBlob
 * @returns {Promise<string>}
 */
export async function uploadImageWithBlob(imageBlob: Blob) {
  const client = getNftStorageClient();
  const cid = await client.storeBlob(imageBlob);
  const storageUrl = `https://nftstorage.link/ipfs/${cid}`;
  return storageUrl;
}

/**
 * Store nft metadata to nft.storage.  Returns the uri of the metadata.
 * @param {AnchorWallet} wallet
 * @param {NftCreateData} nftData
 * @returns {Promise<string>}
 */
export async function uploadMetadata(wallet: AnchorWallet, nftData: NftCreateData) {
  const client = getNftStorageClient();
  const metaplex = Metaplex.make(connection)
    .use(walletAdapterIdentity(wallet))
    .use(nftStorage(client));

  const uploadMetadata = await metaplex.nfts().uploadMetadata({
    name: nftData.name,
    description: nftData.description,
    image: nftData.image,
    symbol: nftData.symbol,
    sellerFeeBasisPoints: nftData.sellerFeeBasisPoints * 100,
    creators: [
      {
        address: wallet.publicKey?.toBase58()!,
        share: 100,
      },
    ],
    properties: {
      files: [
        {
          uri: nftData.image,
          type: "image/png",
        },
      ],
    },
    attributes: [
      {
        trait_type: "Generated By",
        value: "Sapphire Tool",
      },
    ],
  });

  return uploadMetadata.uri;
}

/**
 * Instantiate a Metaplex Umi instance using the wallet passed in.  Returns Umi instance.
 * @param {AnchorWallet} wallet
 * @returns {Umi}
 */
export function returnUmiIdentity(wallet: AnchorWallet) {
  const umi = createUmi(process.env.NEXT_PUBLIC_RPC!);
  umi.use(umiWalletAdapterIdentity(wallet));
  return umi;
}

/**
 * Instantiate a Metaplex instance using the wallet passed in and the nft.storage client.  Returns Metaplex instance.
 * @param {AnchorWallet} wallet
 * @param {client} NftStorageDriverOptions
 * @returns {Metaplex}
 */
export function getMetaplexConnection(wallet: AnchorWallet, client: NftStorageDriverOptions) {
  const metaplex = Metaplex.make(connection)
    .use(walletAdapterIdentity(wallet))
    .use(nftStorage(client));
  return metaplex;
}

/**
 * Returns a Solana Transaction object for the purchase of a pricing package in SOL.
 * @param {PricingPackagesTypes} PurchasePackage
 * @param {string} wallet
 * @returns {Transaction}
 */
export async function purchaseInSol(PurchasePackage: PricingPackagesTypes, wallet: string) {
  const { data: solPriceReq } = await axios.get(
    "https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd"
  );
  const solPrice = solPriceReq.solana.usd;
  const packagePriceInSol = parseInt(((PurchasePackage.priceUsd / solPrice) * 10 ** 9).toFixed(9));

  console.log("packagePriceInSol", packagePriceInSol);
  const solTx = new Transaction().add(
    SystemProgram.transfer({
      fromPubkey: new PublicKey(wallet),
      toPubkey: paymentWallet,
      lamports: packagePriceInSol,
    })
  );
  return solTx;
}

/**
 * Returns a Solana Transaction object for the purchase of a pricing package in USDC.
 * @param {PricingPackagesTypes} PurchasePackage
 * @param {string} wallet
 * @returns {Transaction}
 */
export async function purchaseInUsdc(PurchasePackage: PricingPackagesTypes, wallet: string) {
  const walletUsdcAccount = await getUsdcAccount(wallet);
  const usdcTx = new Transaction().add(
    splToken.createTransferCheckedInstruction(
      walletUsdcAccount,
      USDC,
      paymentWalletUSDC,
      new PublicKey(wallet),
      PurchasePackage.priceUsd * 1000000,
      6,
      [],
      splToken.TOKEN_PROGRAM_ID
    )
  );
  return usdcTx;
}

/**
 * Get the USDC balance of a wallet. Returns true balance for uiAmount divide by 10^6.
 * @param {string} wallet
 * @returns {number}
 */
export async function getUsdcBalance(wallet: string) {
  const accountInfo = await connection.getParsedTokenAccountsByOwner(new PublicKey(wallet), {
    mint: USDC,
  });
  const usdcBalance = accountInfo.value[0]?.account?.data?.parsed?.info?.tokenAmount?.amount || 0;
  return usdcBalance;
}

/**
 * Get the SOL balance of a wallet. Returns true balance for uiAmount divide by 10^9.
 * @param {string} wallet
 * @returns {number}
 */
export async function getSolBalance(wallet: string) {
  const balance = await connection.getBalance(new PublicKey(wallet));
  return balance;
}

/**
 * Get the USDC account of a wallet. Returns the account publicKey.
 * @async
 * @param {string} wallet
 * @returns {Promise<PublicKey>}
 */
export async function getUsdcAccount(wallet: string) {
  const usdcAccount = await splToken.getAssociatedTokenAddress(USDC, new PublicKey(wallet));
  return usdcAccount;
}
export async function purchaseInBonk(PurchasePackage: PricingPackagesTypes, wallet: string, tokenPrice: number) {
  const senderTokenAccount = await connection.getParsedTokenAccountsByOwner(new PublicKey(wallet), { mint: new PublicKey(bonk) });
  const recipientTokenAccount = await connection.getParsedTokenAccountsByOwner(paymentWallet, { mint: new PublicKey(bonk) });

  let ix: TransactionInstruction[]
  if (recipientTokenAccount.value.length === 0) {
    const associatedTokenAccount = splToken.getAssociatedTokenAddressSync(new PublicKey(bonk), paymentWallet)
    ix = [
      splToken.createAssociatedTokenAccountInstruction(
        new PublicKey(wallet),
        associatedTokenAccount,
        paymentWallet,
        new PublicKey(bonk),
        splToken.TOKEN_PROGRAM_ID,
        splToken.ASSOCIATED_TOKEN_PROGRAM_ID
      ),
      splToken.createTransferCheckedInstruction(
        senderTokenAccount.value[0].pubkey,
        new PublicKey(bonk),
        associatedTokenAccount,
        new PublicKey(wallet),
        Math.ceil(PurchasePackage.priceUsd / tokenPrice) * 10 ** 5,
        5,
        [],
        splToken.TOKEN_PROGRAM_ID
      )
    ]
  } else {
    ix = [
      splToken.createTransferCheckedInstruction(
        senderTokenAccount.value[0].pubkey,
        new PublicKey(bonk),
        recipientTokenAccount.value[0].pubkey,
        new PublicKey(wallet),
        Math.ceil(PurchasePackage.priceUsd / tokenPrice) * 10 ** 5,
        5,
        [],
        splToken.TOKEN_PROGRAM_ID
      )
    ]
  }
  const bonkTx = new Transaction().add(
    ...ix
  );
  return bonkTx;
}
export async function purchaseInGecko(PurchasePackage: PricingPackagesTypes, wallet: string, tokenPrice: number) {
  const senderTokenAccount = await connection.getParsedTokenAccountsByOwner(new PublicKey(wallet), { mint: new PublicKey(gecko) });
  const recipientTokenAccount = await connection.getParsedTokenAccountsByOwner(paymentWallet, { mint: new PublicKey(gecko) });

  let ix: TransactionInstruction[]
  if (recipientTokenAccount.value.length === 0) {
    const associatedTokenAccount = splToken.getAssociatedTokenAddressSync(new PublicKey(gecko), paymentWallet)
    ix = [
      splToken.createAssociatedTokenAccountInstruction(
        new PublicKey(wallet),
        associatedTokenAccount,
        paymentWallet,
        new PublicKey(gecko),
        splToken.TOKEN_PROGRAM_ID,
        splToken.ASSOCIATED_TOKEN_PROGRAM_ID
      ),
      splToken.createTransferCheckedInstruction(
        senderTokenAccount.value[0].pubkey,
        new PublicKey(gecko),
        associatedTokenAccount,
        new PublicKey(wallet),
        Math.ceil(PurchasePackage.priceUsd / tokenPrice) * 10 ** 6,
        6,
        [],
        splToken.TOKEN_PROGRAM_ID
      )
    ]
  } else {
    ix = [
      splToken.createTransferCheckedInstruction(
        senderTokenAccount.value[0].pubkey,
        new PublicKey(gecko),
        recipientTokenAccount.value[0].pubkey,
        new PublicKey(wallet),
        Math.ceil(PurchasePackage.priceUsd / tokenPrice) * 10 ** 6,
        6,
        [],
        splToken.TOKEN_PROGRAM_ID
      )
    ]
  }
  const geckoTx = new Transaction().add(
    ...ix
  );
  return geckoTx;
}
export async function purchaseInWif(PurchasePackage: PricingPackagesTypes, wallet: string, tokenPrice: number) {
  const senderTokenAccount = await connection.getParsedTokenAccountsByOwner(new PublicKey(wallet), { mint: new PublicKey(dogWifHat) });
  const recipientTokenAccount = await connection.getParsedTokenAccountsByOwner(paymentWallet, { mint: new PublicKey(dogWifHat) });

  let ix: TransactionInstruction[]
  if (recipientTokenAccount.value.length === 0) {
    const associatedTokenAccount = splToken.getAssociatedTokenAddressSync(new PublicKey(dogWifHat), paymentWallet)
    ix = [
      splToken.createAssociatedTokenAccountInstruction(
        new PublicKey(wallet),
        associatedTokenAccount,
        paymentWallet,
        new PublicKey(dogWifHat),
        splToken.TOKEN_PROGRAM_ID,
        splToken.ASSOCIATED_TOKEN_PROGRAM_ID
      ),
      splToken.createTransferCheckedInstruction(
        senderTokenAccount.value[0].pubkey,
        new PublicKey(dogWifHat),
        associatedTokenAccount,
        new PublicKey(wallet),
        Math.ceil(PurchasePackage.priceUsd / tokenPrice) * 10 ** 6,
        6,
        [],
        splToken.TOKEN_PROGRAM_ID
      )
    ]
  } else {
    ix = [
      splToken.createTransferCheckedInstruction(
        senderTokenAccount.value[0].pubkey,
        new PublicKey(dogWifHat),
        recipientTokenAccount.value[0].pubkey,
        new PublicKey(wallet),
        Math.ceil(PurchasePackage.priceUsd / tokenPrice) * 10 ** 6,
        6,
        [],
        splToken.TOKEN_PROGRAM_ID
      )
    ]
  }
  const dogWifHatTx = new Transaction().add(
    ...ix
  );
  return dogWifHatTx;
}
export async function purchaseInShdw(PurchasePackage: PricingPackagesTypes, wallet: string, tokenPrice: number) {
  const senderTokenAccount = await connection.getParsedTokenAccountsByOwner(new PublicKey(wallet), { mint: new PublicKey(shdw) });
  const recipientTokenAccount = await connection.getParsedTokenAccountsByOwner(paymentWallet, { mint: new PublicKey(shdw) });

  let ix: TransactionInstruction[]
  if (recipientTokenAccount.value.length === 0) {
    const associatedTokenAccount = splToken.getAssociatedTokenAddressSync(new PublicKey(shdw), paymentWallet)
    ix = [
      splToken.createAssociatedTokenAccountInstruction(
        new PublicKey(wallet),
        associatedTokenAccount,
        paymentWallet,
        new PublicKey(shdw),
        splToken.TOKEN_PROGRAM_ID,
        splToken.ASSOCIATED_TOKEN_PROGRAM_ID
      ),
      splToken.createTransferCheckedInstruction(
        senderTokenAccount.value[0].pubkey,
        new PublicKey(shdw),
        associatedTokenAccount,
        new PublicKey(wallet),
        Math.ceil(PurchasePackage.priceUsd / tokenPrice) * 10 ** 9,
        9,
        [],
        splToken.TOKEN_PROGRAM_ID
      )
    ]
  } else {
    ix = [
      splToken.createTransferCheckedInstruction(
        senderTokenAccount.value[0].pubkey,
        new PublicKey(shdw),
        recipientTokenAccount.value[0].pubkey,
        new PublicKey(wallet),
        Math.ceil(PurchasePackage.priceUsd / tokenPrice) * 10 ** 9,
        9,
        [],
        splToken.TOKEN_PROGRAM_ID
      )
    ]
  }
  const shdwTx = new Transaction().add(
    ...ix
  );
  return shdwTx;
}
export async function getTokenBalances(wallet: PublicKey) {
  const solBalance = await connection.getBalance(wallet);
  const tokens = [
    { token: "usdc", mint: USDC.toBase58() },
    { token: "bonk", mint: bonk },
    { token: "dogwifhat", mint: dogWifHat },
    { token: "gecko", mint: gecko },
    { token: "shdw", mint: shdw }
  ]

  const tokenBalances = await Promise.all(tokens.map(async (token) => {
    const tokenAccount = await connection.getParsedTokenAccountsByOwner(wallet, { mint: new PublicKey(token.mint) })
    const balance = tokenAccount.value[0]?.account?.data?.parsed?.info?.tokenAmount?.amount || 0;
    return { token: token.token, balance: balance }
  }))

  return {
    sol: solBalance,
    usdc: parseInt(tokenBalances.find((token) => token.token === "usdc")?.balance) || 0,
    bonk: parseInt(tokenBalances.find((token) => token.token === "bonk")?.balance) || 0,
    dogWifHat: parseInt(tokenBalances.find((token) => token.token === "dogwifhat")?.balance) || 0,
    gecko: parseInt(tokenBalances.find((token) => token.token === "gecko")?.balance) || 0,
    shdw: parseInt(tokenBalances.find((token) => token.token === "shdw")?.balance) || 0
  }
}

/**
 * Get a Metaplex Builder for the creation of a standard NFT.  Returns the builder.
 * @param {AnchorWallet} wallet
 * @param {boolean} addCollection
 * @param {NftCreateData} nftData
 * @returns {Promise<TransactionBuilder<CreateNftBuilderContext>>}
 */
export async function createStandardNft(
  wallet: AnchorWallet,
  addCollection: boolean,
  nftData: NftCreateData
) {
  const client = getNftStorageClient();
  const metaplex = Metaplex.make(connection)
    .use(walletAdapterIdentity(wallet))
    .use(nftStorage(client));

  const uri = await uploadMetadata(wallet, nftData);

  const nftBuilder = await metaplex
    .nfts()
    .builders()
    .create({
      uri: uri,
      name: nftData.name,
      sellerFeeBasisPoints: nftData.sellerFeeBasisPoints * 100,
      symbol: nftData.symbol,
      isMutable: nftData.isMutable,
      collection: addCollection ? new PublicKey(nftData.collection!) : null,
    });

  if (addCollection) {
    const ctx = nftBuilder.getContext();
    const collectionBuilder = metaplex
      .nfts()
      .builders()
      .verifyCollection({
        collectionMintAddress: new PublicKey(nftData.collection!),
        mintAddress: ctx.mintAddress,
      });
    nftBuilder.add(collectionBuilder);
  }
  return nftBuilder;
}

/**
 * Get a Metaplex Builder for the creation of a MCC collection NFT.  Returns the builder.
 * @param {AnchorWallet} wallet
 * @param {NftCreateData} nftData
 * @returns {Promise<TransactionBuilder<CreateNftBuilderContext>>}
 */
export async function createCollectionNft(
  wallet: AnchorWallet,
  nftData: NftCreateData
): Promise<TransactionBuilder<CreateNftBuilderContext>> {
  const client = getNftStorageClient();
  const metaplex = Metaplex.make(connection)
    .use(walletAdapterIdentity(wallet))
    .use(nftStorage(client));

  const uri = await uploadMetadata(wallet, nftData);

  const nftBuilder = await metaplex
    .nfts()
    .builders()
    .create({
      uri: uri,
      name: nftData.name,
      sellerFeeBasisPoints: nftData.sellerFeeBasisPoints * 100,
      symbol: nftData.symbol,
      isMutable: nftData.isMutable,
      isCollection: true,
    });

  return nftBuilder;
}

/**
 * Get a Transaction Object for a cNft mint to a Sapphire merkle tree and Sapphire Collection.  Returns the transaction.
 * @param {AnchorWallet} wallet
 * @param {string} image
 * @param {string} name
 * @param {string} creatorWallet
 * @returns {Transaction}
 */
export async function mintPublicCnft(
  wallet: AnchorWallet,
  image: string,
  name: string,
  creatorWallet: string,
) {
  const umi = returnUmiIdentity(wallet);
  const nftData = {
    name: name,
    description: `Generated by ${creatorWallet} using Sapphire Tool`,
    image: image,
    symbol: "SAPPHIRE",
    sellerFeeBasisPoints: 700,
    isMutable: false,
  };
  const uri = await uploadMetadata(wallet, nftData);

  const cnftTx = mintV1(umi, {
    leafOwner: umi.identity.publicKey,
    merkleTree: publicKey(merkleTree.toBase58()),
    metadata: {
      name: name,
      uri: uri,
      symbol: "SAPPHIRE",
      sellerFeeBasisPoints: 700,
      creators: [
        {
          address: publicKey(creatorWallet),
          verified: false,
          share: 75,
        },
        {
          address: publicKey(paymentWallet.toBase58()),
          verified: false,
          share: 25,
        }
      ],
      collection: { key: publicKey(sapphireCollectionMint.toBase58()), verified: false }
    },
  })

  return { builder: cnftTx, umi: umi };
}
/**
 * Get a Transaction Object for a cNft mint to a Sapphire merkle tree.  Returns the transaction.
 * @param {AnchorWallet} wallet
 * @param {string} image
 * @param {string} name
 * @param {string} creatorWallet
 * @param {string} description
 * @param {string} symbol
 * @param {number} sellerFeeBasisPoints
 * @param {boolean} isMutable
 * @returns {Transaction}
 */
export async function mintPrivateCnft(
  wallet: AnchorWallet,
  image: string,
  name: string,
  creatorWallet: string,
  description: string,
  sellerFeeBasisPoints: number,
  symbol: string,
  isMutable: boolean,
) {
  const umi = returnUmiIdentity(wallet);
  const nftData = {
    name: name,
    description: description,
    image: image,
    symbol: symbol,
    sellerFeeBasisPoints: sellerFeeBasisPoints,
    isMutable: isMutable,
  };
  const uri = await uploadMetadata(wallet, nftData);

  const cnftTx = mintV1(umi, {
    leafOwner: umi.identity.publicKey,
    merkleTree: publicKey(privateMerkleTree.toBase58()),
    metadata: {
      name: name,
      uri: uri,
      symbol: symbol,
      sellerFeeBasisPoints: sellerFeeBasisPoints,
      creators: [
        {
          address: publicKey(creatorWallet),
          verified: false,
          share: 100,
        }
      ],
      collection: none(),
    },
  })

  return { builder: cnftTx, umi: umi };
}

/**
 * Get a Metaplex builder for a sol fee. Returns builder
 * @param {AnchorWallet} wallet
 * @returns {TransactionBuilder<object>}
 */
export async function createFeeIx(wallet: AnchorWallet, isCnft: boolean) {
  const metaplex = Metaplex.make(connection).use(walletAdapterIdentity(wallet));

  const feeBuilder = metaplex
    .system()
    .builders()
    .transferSol({
      to: paymentWallet,
      amount: isCnft ? sol(0.001) : sol(0.03),
    });
  return feeBuilder;
}


/**
 * Get a Transaction Builder for a pNFT mint.  Returns the builder.
 * @param {AnchorWallet} wallet
 * @param {string} image
 * @param {string} name
 * @param {string} creatorWallet
 * @param {string} description
 * @param {string} symbol
 * @param {number} sellerFeeBasisPoints
 * @param {boolean} isMutable
 * @returns {Promise<TransactionBuilder<CreateNftBuilderContext>>}
 */
export async function mintPnftBuilder(
  wallet: AnchorWallet,
  nftData: NftCreateData
) {
  const client = getNftStorageClient();
  const metaplex = Metaplex.make(connection)
    .use(walletAdapterIdentity(wallet))
    .use(nftStorage(client));

  const uri = await uploadMetadata(wallet, nftData);

  const nftBuilder = await metaplex
    .nfts()
    .builders()
    .create({
      uri: uri,
      name: nftData.name,
      sellerFeeBasisPoints: nftData.sellerFeeBasisPoints * 100,
      symbol: nftData.symbol,
      isMutable: nftData.isMutable,
      tokenStandard: TokenStandard.ProgrammableNonFungible
    });

  return nftBuilder;
}

export async function getFeeAsVersionedMessageTx(
  wallet: AnchorWallet,
  fee: number,

) {
  const instructions = [
    SystemProgram.transfer({
      fromPubkey: wallet.publicKey!,
      toPubkey: paymentWallet,
      lamports: fee,
    }),
  ]

  const message = new TransactionMessage({
    payerKey: wallet.publicKey!,
    recentBlockhash: (await connection.getRecentBlockhash()).blockhash,
    instructions: instructions,
  }).compileToV0Message();


  return message;

}


/**
 * Burn standard and pnfts.  Returns the transaction.
 * @param {AnchorWallet} wallet
 * @param {Array<BurnableNfts>} nfts
 * @returns {Transaction[]}}
 */
export async function buildBurnTxs(wallet: AnchorWallet, nfts: BurnableNfts[]) {
  const umi = returnUmiIdentity(wallet);
  umi.use(mplTokenMetadata())


  let txs = [];

  for (const nft of nfts) {

    const burnAccounts = await getBurnAccounts(nft.mint, wallet, nft.collection || null, umi);
    const tx = burnV1(umi, {
      mint: publicKey(nft.mint),
      token: fromWeb3JsPublicKey(burnAccounts.tokenAccount),
      collectionMetadata: burnAccounts.collectionMetadata ? burnAccounts.collectionMetadata : undefined,
      tokenStandard: nft.type === "standard" ? TokenStandard.NonFungible : TokenStandard.ProgrammableNonFungible
    })

    txs.push(tx)
  }

  return { txs: txs, umi: umi }
}


export async function getBurnAccounts(mint: string, wallet: AnchorWallet, collection: string | null, umi: Umi) {

  const masterEdition = findMasterEditionPda(umi, {
    mint: publicKey(mint),
  });
  const tokenAccounts = await connection.getParsedTokenAccountsByOwner(wallet.publicKey!, {
    mint: new PublicKey(mint),
  })
  const tokenAccount = tokenAccounts.value[0].pubkey;
  const metadata = findMetadataPda(umi, {
    mint: publicKey(mint),
  })
  if (collection) {
    const collectionMetadata = findMetadataPda(umi, {
      mint: publicKey(collection),
    })
    return {
      masterEdition: masterEdition,
      tokenAccount: tokenAccount,
      metadata: metadata,
      collectionMetadata: collectionMetadata
    }
  } else {
    return {
      masterEdition: masterEdition,
      tokenAccount: tokenAccount,
      metadata: metadata,
    }
  }
}
export async function getNftData(mint: string, solanaEnv: "mainnet" | "devnet") {
  const HELIUS_KEY = process.env.HELIUS_KEY!

  const url = solanaEnv === "mainnet"
    ? `https://mainnet.helius-rpc.com/?api-key=${HELIUS_KEY}`
    : `https://devnet.helius-rpc.com/?api-key=${HELIUS_KEY}`

  const { data } = await axios.post(url, JSON.stringify({
    jsonrpc: "2.0",
    id: "get-nft",
    method: "getAsset",
    params: {
      id: mint
    }
  }), {
    headers: {
      'Content-Type': 'application/json'
    }
  })

  const uri = data.result.content.json_uri

  const { data: metadata } = await axios.get(uri)

  return {
    name: metadata.name,
    uri: uri,
    image: metadata.image,
    symbol: metadata.symbol,
    sellerFeeBasisPoints: metadata.seller_fee_basis_points
  }
}

export async function tipInSol(from: string, to: string, amount: number) {
  const tx = new Transaction().add(
    SystemProgram.transfer({
      fromPubkey: new PublicKey(from),
      toPubkey: new PublicKey(to),
      lamports: amount,
    })
  );
  return tx;
}
